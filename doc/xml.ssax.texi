@node xml ssax, Naming Conventions, term ansi-color, Top
@chapter (xml ssax) 

@cindex XML, parser
@cindex parser, XML
@cindex SSAX
@cindex SAX

The @acronym{SSAX} @acronym{XML} parser is a functional framework for
creating @acronym{SAX} and @acronym{DOM} parsers with support for
@acronym{XML} Namespaces and validation. It was written by Oleg
Kiselyov. This documentation is an adaptation of notes from his
original @acronym{SSAX} distribution.

Oleg refers to this work as a set of ``Lego blocks'', meaning that it
contains tools that can create parsers. Users that just want to
transform @acronym{XML} to s-expressions might be interested in
@@ref@{xml parse@}, which is based on this package.

@section Background

The routines in @acronym{SSAX} package range from low-level
@acronym{SAX} parser generators, suitable for permissive HTML parsing,
to high level parsers that translate angle-bracket @acronym{XML} to
s-expression realizations of the DOM. The procedures in the package
can be used separately to tokenize or parse various pieces of
@acronym{XML} documents, or to create a custom parser for a specific
document type.

@acronym{SSAX} supports @acronym{XML} Namespaces, internal and
external parsed entities, user-controlled handling of whitespace, and
validation. This module therefore is intended to be a framework that
you can use to build a parser following any discipline and performing
validation to any degree. As an example of the parser construction,
this file includes a semi-validating @acronym{SXML} parser.

The present @acronym{XML} framework has a ``sequential'' feel of
@acronym{SAX} yet a ``functional style'' of DOM. Like a @acronym{SAX}
parser, the framework scans the document only once and permits
incremental processing. An application that handles document elements
in order can run as efficiently as possible. @emph{Unlike} a
@acronym{SAX} parser, the framework does not require an application
register stateful callbacks and surrender control to the parser.
Rather, it is the application that can drive the framework -- calling
its functions to get the current lexical or syntax element. These
functions do not maintain or mutate any state save the input port.
Therefore, the framework permits parsing of @acronym{XML} in a pure
functional style, with the input port being a monad (or a linear,
read-once parameter).

Besides the port, there is another monad -- @var{seed}. Most of the
middle- and high-level parsers are single-threaded through the seed.
The functions of this framework do not process or affect the seed in
any way: they simply pass it around as an instance of an opaque
datatype. User functions, on the other hand, can use the seed to
maintain user's state, to accumulate parsing results, etc. A user can
freely mix his own functions with those of the framework. On the other
hand, the user may wish to instantiate a high-level parser:
@code{SSAX:make-elem-parser} or @code{SSAX:make-parser}. In the latter
case, the user must provide functions of specific signatures, which
are called at predictable moments during the parsing: to handle
character data, element data, or processing instructions
(@acronym{PI}). The functions are always given the seed, among other
parameters, and must return the new seed.

From a functional point of view, @acronym{XML} parsing is a combined
pre-post-order traversal of a ``tree'' that is the @acronym{XML}
document itself. This down-and-up traversal tells the user about an
element when its start tag is encountered. The user is notified about
the element once more, after all element's children have been handled.
The process of @acronym{XML} parsing therefore is a fold over the raw
@acronym{XML} document. Unlike a fold over trees defined in [1], the
parser is necessarily single-threaded -- obviously as elements in a
text @acronym{XML} document are laid down sequentially. The parser
therefore is a tree fold that has been transformed to accept an
accumulating parameter [1,2].

Formally, the denotational semantics of the parser can be expressed
as:

@smallexample
parser:: (Start-tag -> Seed -> Seed) ->
         (Start-tag -> Seed -> Seed -> Seed) ->
         (Char-Data -> Seed -> Seed) ->
         XML-text-fragment -> Seed -> Seed
parser fdown fup fchar "<elem attrs> content </elem>" seed
 = fup "<elem attrs>" seed
      (parser fdown fup fchar "content" (fdown "<elem attrs>" seed))

parser fdown fup fchar "char-data content" seed
 = parser fdown fup fchar "content" (fchar "char-data" seed)

parser fdown fup fchar "elem-content content" seed
 = parser fdown fup fchar "content" (
      parser fdown fup fchar "elem-content" seed)
@end smallexample

@noindent Compare the last two equations with the left fold:

@smallexample
fold-left kons elem:list seed = fold-left kons list (kons elem seed)
@end smallexample

The real parser created by @code{SSAX:make-parser} is slightly more
complicated, to account for processing instructions, entity
references, namespaces, processing of document type declaration, etc.

The @acronym{XML} standard document referred to in this module is
@uref{http://www.w3.org/TR/1998/REC-xml-19980210.html}.

The present file also defines a procedure that parses the text of an
@acronym{XML} document or of a separate element into SXML, an
S-expression-based model of an @acronym{XML} Information Set.
@acronym{SXML} is also an Abstract Syntax Tree of an @acronym{XML}
document. @acronym{SXML} is similar but not identical to DOM;
@acronym{SXML} is particularly suitable for Scheme-based XML/HTML
authoring, SXPath queries, and tree transformations. See SXML.html for
more details. @acronym{SXML} is a term implementation of evaluation of
the @acronym{XML} document [3]. The other implementation is
context-passing.

The present framework fully supports the
@uref{http://www.w3.org/TR/REC-xml-names/,@acronym{XML} Namespaces
Recommendation}.

Other links:

@enumerate
@item Jeremy Gibbons, Geraint Jones, ``The Under-appreciated Unfold,''
Proc. ICFP'98, 1998, pp. 273-279.
@item Richard S. Bird, The promotion and accumulation strategies in
transformational programming, ACM Trans. Progr. Lang. Systems,
6(4):487-504, October 1984.
@item Ralf Hinze, ``Deriving Backtracking Monad Transformers,''
Functional Pearl. Proc ICFP'00, pp. 186-197.
@end enumerate

@section Error Handling

If the parser encounters an error, it will throw an exception to the
key @code{parser-error}. The arguments will be of the form

@lisp
  (PORT MESSAGE SPECIALISING-MSG*)
@end lisp

The first argument is a port, which typically points to the offending
character or its neighborhood. You can then use @code{port-column} and
@code{port-line} to query the current position. @var{message} is the
description of the error. Other arguments supply more details about
the problem.

In addition, the present code invokes @code{SSAX:warn} to notify the
user about warnings that are NOT errors but might be of interest to
the user. At some point in time we should replace this method with
something extensible.

@section API

Currently, the only API reference is either in the source, or on
@uref{http://ssax.sourceforge.net}. Documentation patches accepted!

@ignore
   arch-tag: 29c9095c-3866-4571-8703-74368284f02e
@end ignore
