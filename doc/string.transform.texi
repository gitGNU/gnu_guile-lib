@node string transform, string wrap, string soundex, Top
@chapter (string transform)

Module @samp{(string transform)} provides functions for modifying
strings beyond that which is provided in the guile core and
@samp{(srfi srfi-13)}.  

@defun transform-string str match? replace [start] [end]
Uses @var{match?} against each character in @var{str}, and performs a
replacement on each character for which matches are found.

@var{match?} may either be a function, a character, a string, or
@code{#t}.  If @var{match?}  is a function, then it takes a single
character as input, and should return @samp{#t} for matches.
@var{match?} is a character, it is compared to each string character
using @code{char=?}.  If @var{match?} is a string, then any character
in that string will be considered a match.  @code{#t} will cause 
every character to be a match.

If @var{replace} is a function, it is called with the matched
character as an argument, and the returned value is sent to the output
string via @samp{display}.  If @var{replace} is anything else, it is
sent through the output string via @samp{display}.

Note that te replacement for the matched characters does not need to
be a single character.  That is what differentiates this function from
@samp{string-map}, and what makes it useful for applications such as
converting @samp{#\&} to @samp{"&amp;"} in web page text.  Some other
functions in this module are just wrappers around common uses of
@samp{transform-string}.  Transformations not possible with this
function should probably be done with regular expressions.

If @var{start} and @var{end} are given, they control which portion
of the string undergoes transformation.  The entire input string
is still output, though.  So, if @var{start} is @samp{5}, then the
first five characters of @var{str} will still appear in the returned
string.

@lisp
; these two are equivalent...
(transform-string str #\space #\-) ; change all spaces to -'s
(transform-string str (lambda (c) (char=? #\space c)) #\-)
@end lisp
@end defun

@defun expand-tabs str [tab-size]
Returns a copy of @var{str} with all tabs expanded to spaces.
@var{tab-size} defaults to 8.

Assuming tab size of 8, this is equivalent to:
@lisp
(transform-string str #\tab "        ")
@end lisp
@end defun

@defun escape-special-chars str special-chars escape-char
Returns a copy of @var{str} with all given special characters preceded
by the given @var{escape-char}.

@var{special-chars} can either be a single character, or a string consisting
of all the special characters.

@lisp
;; make a string regexp-safe...
(escape-special-chars "***(Example String)***"  
                      "[]()/*." 
                      #\\)
=> "\\*\\*\\*\\(Example String\\)\\*\\*\\*"

;; also can escape a singe char...
(escape-special-chars "richardt@@vzavenue.net"
                      #\@@
                      #\@@)
=> "richardt@@@@vzavenue.net"
@end lisp
@end defun

@defun center-string str [width] [chr] [rchr]
Returns a copy of @var{str} centered in a field of @var{width}
characters.  Any needed padding is done by character @var{chr}, which
defaults to @samp{#\space}.  If @var{rchr} is provided, then the
padding to the right will use it instead.  See the examples below.
left and @var{rchr} on the right.  The default @var{width} is 80.  The
default @var{lchr} and @var{rchr} is @samp{#\space}.  The string is
never truncated.
@lisp
(center-string "Richard Todd" 24)
=> "      Richard Todd      "

(center-string " Richard Todd " 24 #\=)
=> "===== Richard Todd ====="

(center-string " Richard Todd " 24 #\< #\>)
=> "<<<<< Richard Todd >>>>>"
@end lisp
@end defun

@defun left-justify-string str [width] [chr]
Returns a copy of @var{str} padded with @var{chr} such that it is left
justified in a field of @var{width} characters.  The default
@var{width} is 80.  Unlike @samp{string-pad} from srfi-13, the string
is never truncated.
@end defun

@defun right-justify-string str [width] [chr]
Returns a copy of @var{str} padded with @var{chr} such that it is
right justified in a field of @var{width} characters.  The default
@var{width} is 80.  The default @var{chr} is @samp{#\space}.  Unlike
@samp{string-pad} from srfi-13, the string is never truncated.
@end defun

@defun collapse-repeated-chars str [chr] [num]
Returns a copy of @var{str} with all repeated instances of 
@var{chr} collapsed down to at most @var{num} instances.
The default value for @var{chr} is @samp{#\space}, and 
the default value for @var{num} is 1.

@lisp
(collapse-repeated-chars "H  e  l  l  o")
=> "H e l l o"
(collapse-repeated-chars "H--e--l--l--o" #\-)
=> "H-e-l-l-o"
(collapse-repeated-chars "H-e--l---l----o" #\- 2)
=> "H-e--l--l--o"
@end lisp
@end defun

@ignore
   arch-tag: eedd5d12-2b9b-4278-aeed-8cafad686092
@end ignore
